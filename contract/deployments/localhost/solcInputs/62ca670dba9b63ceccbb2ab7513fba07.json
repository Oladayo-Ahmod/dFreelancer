{
  "language": "Solidity",
  "sources": {
    "contracts/Employer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport \"./Job.sol\";\r\n\r\n\r\ncontract Employers is Djob{\r\n\r\n    \r\n    /// @notice retrieves employer by address\r\n    /// @param _employer, address\r\n    /// @return props\r\n    function getEmployerByAddress(address _employer) external view returns(Employer memory props){\r\n        props = employers[_employer];\r\n    }\r\n\r\n    \r\n     /// @notice retrieves employer escrow balance\r\n    /// @param _employer, @param _job_id\r\n    /// @return uint\r\n    function getEmployerEscrow(address _employer, uint256 _job_id) external view returns(uint){\r\n        return escrowFunds[_employer][_job_id];\r\n\r\n    }\r\n\r\n     /// @notice process employer registration\r\n        /// @param _name , @param _industry\r\n      function registerEmployer\r\n      (string memory _name, string memory _industry,string memory _country, string memory _imageURI, string memory _date) public {\r\n        require(employers[msg.sender].registered == false, 'AR'); // already registered\r\n        require(bytes(_name).length > 0);\r\n        require(bytes(_industry).length > 0);\r\n        totalEmployers++;\r\n        employers[msg.sender] = Employer(msg.sender, _name, _industry, 0,_country, _imageURI,true,_date);\r\n        emit EmployerRegistered(msg.sender, _name);\r\n    }\r\n\r\n      /// @notice hiring freelancer and check if freelancer is not already hired for the job\r\n    /// @param jobId, @param freelancerAddress\r\n    function hireFreelancer(uint jobId, address freelancerAddress) public onlyEmployer(msg.sender) {\r\n        require(jobId <= totalJobs && jobId > 0, \"JDE.\"); // job does not exist\r\n        Job storage job = jobs[jobId];\r\n        require(job.employer != address(0), \"JNF\"); // Job not found\r\n        require(!isFreelancerHired(job, freelancerAddress), \"FAH\"); //Freelancer is already hired\r\n\r\n        job.hiredFreelancer = freelancerAddress;\r\n    \r\n    }\r\n\r\n     /// @notice retrieves all uncompleted jobs by employer\r\n    /// @return props\r\n\r\n    // function allUncompletedJobsByEmployer() external view returns(Job[] memory props){\r\n    //     uint totalEmployerJobs = 0;\r\n    //     uint currentIndex = 0;\r\n\r\n    //     // count total jobs created and uncompleted by employer\r\n    //     for (uint i = 0; i < totalJobs; i++) {\r\n    //         if (jobs[i +1].employer == msg.sender && jobs[i+1].completed == false) {\r\n    //             totalEmployerJobs++;\r\n    //         }\r\n    //     }\r\n\r\n    //     // get the jobs created and uncompleted by employer\r\n    //     props = new Job[](totalEmployerJobs);\r\n    //     for (uint i = 0; i < totalJobs; i++) {\r\n    //         if (jobs[i+1].employer == msg.sender && jobs[i+1].completed == false) {\r\n    //             uint currentId = i + 1;\r\n    //             // Job storage currentJob = jobs[currentId];\r\n    //             props[currentIndex] = jobs[currentId];\r\n    //             currentIndex++;\r\n    //         }\r\n\r\n    //     }\r\n    // }\r\n}"
    },
    "contracts/Freelancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport \"./Employer.sol\";\r\n\r\ncontract Dfreelancer is Employers { \r\n   \r\n\r\n     /// @notice retrieves freelancer by address\r\n    /// @param _freelancer, address\r\n    /// @return props\r\n    function getFreelancerByAddress(address _freelancer) external view returns(Freelancer memory props){\r\n        props = freelancers[_freelancer];\r\n    }\r\n\r\n    /// @notice process freelancer registration\r\n    /// @param _name , @param _skills\r\n    function registerFreelancer\r\n    (string memory _name, string memory _skills, string memory _country,string memory _imageURI,\r\n    string memory _gigTitle, string memory _gigDesc,string memory _date, string memory _starting_price) public {\r\n        require(freelancers[msg.sender].registered == false, 'AR'); // already registered\r\n        require(bytes(_name).length > 0);\r\n        require(bytes(_skills).length > 0);\r\n        totalFreelancers++;\r\n        freelancers[msg.sender] = Freelancer(msg.sender, _name, _skills, 0,_country, \r\n        _imageURI,_gigTitle,_gigDesc,0,true,_date,_starting_price);\r\n         // Add the freelancer address to the array\r\n        allFreelancerAddresses.push(msg.sender);\r\n\r\n        emit FreelancerRegistered(msg.sender, _name);\r\n    }\r\n\r\n         /// @notice return all freelancers\r\n    function getAllFreelancers() public view returns (Freelancer[] memory) {\r\n        Freelancer[] memory allFreelancers = new Freelancer[](totalFreelancers);\r\n\r\n        for (uint256 i = 0; i < totalFreelancers; i++) {\r\n            allFreelancers[i] = freelancers[allFreelancerAddresses[i]];\r\n        }\r\n\r\n        return allFreelancers;\r\n    }\r\n\r\n    \r\n        /// @notice process employer funds deposit for a specific job\r\n        /// @param jobId , job id\r\n    function depositFunds(uint jobId) public payable {\r\n        require(jobId <= totalJobs && jobId > 0, \"JDE.\"); // job does not exist\r\n        Job storage job = jobs[jobId];\r\n        Employer storage employer = employers[msg.sender];\r\n        require(job.employer == msg.sender);\r\n        require(!job.completed, \"JAC\"); // Job is already completed.\r\n        require(msg.value >= job.budget, \"IA\"); // Insufficient amount\r\n        \r\n        employer.balance += msg.value;\r\n        escrowFunds[msg.sender][jobId] += msg.value;\r\n        emit FundsDeposited(jobId, msg.sender, msg.value);\r\n    }\r\n\r\n        /// @notice release escrow fund after successful completion of the job\r\n        /// @param jobId , @param freelancerAddress\r\n    function releaseEscrow(uint jobId, address freelancerAddress) public onlyEmployer(msg.sender){\r\n        require(jobId <= totalJobs && jobId > 0, \"JDE.\"); // job does not exist\r\n        Job storage job = jobs[jobId];\r\n        require(msg.sender == job.employer);\r\n        require(job.completed = true, \"JNC\"); // Job is not completed by freelancer\r\n\r\n        uint escrowAmount = escrowFunds[msg.sender][jobId];\r\n\r\n        require(escrowAmount > 0, \"NFE\"); // No funds in escrow\r\n        require(escrowAmount >= job.budget, \"IF\"); // insufficient funds\r\n        escrowFunds[msg.sender][jobId] = 0;        \r\n        // Implement logic to release funds from escrow to the freelancer's address\r\n        Freelancer storage freelancer = freelancers[freelancerAddress];\r\n        freelancer.balance += escrowAmount;\r\n        emit FundsReleased(jobId, freelancerAddress, escrowAmount);\r\n    }\r\n\r\n\r\n    /// @notice process funds withdrawal to the freelancer after successful completion of a job\r\n    function withdrawEarnings() public onlyFreelancer(msg.sender) {\r\n        Freelancer storage freelancer = freelancers[msg.sender];\r\n        require(freelancer.balance > 0, \"NBW\"); // No balance to withdraw.\r\n\r\n        uint balance = freelancer.balance;\r\n        freelancer.balance = 0;\r\n\r\n        (bool success, ) = msg.sender.call{value: balance}(\"\");\r\n        require(success, \"TF\"); // Transfer failed\r\n\r\n        emit WithdrawFund(msg.sender,balance);\r\n    }\r\n}\r\n"
    },
    "contracts/Job.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Djob{\r\n     address public owner;\r\n    uint8 public totalJobs;\r\n    uint public totalFreelancers;\r\n    uint public totalEmployers;\r\n    uint public totalCompletedJobs;\r\n    address[] public allFreelancerAddresses;\r\n\r\n    struct Job {\r\n        uint8 id;\r\n        address employer;\r\n        string title;\r\n        string description;\r\n        uint256 budget;\r\n        bool completed;\r\n        address[] applicants;\r\n        address hiredFreelancer;        \r\n        \r\n    }\r\n\r\n    struct Freelancer {\r\n        address freelancerAddress;\r\n        string name;\r\n        string skills;\r\n        uint balance;\r\n        string country;\r\n        string image;\r\n        string gigTitle;\r\n        string gitDescription;\r\n        uint jobsCompleted;\r\n        bool registered;\r\n        string registration_date;\r\n        string starting_price;\r\n    }\r\n\r\n    \r\n    struct Employer {\r\n        address employerAddress;\r\n        string name;\r\n        string industry;\r\n        uint balance;\r\n        string country;\r\n        string image;\r\n        bool registered;\r\n        string registration_date;\r\n\r\n    }\r\n\r\n    // Job[] public jobs;\r\n    mapping(uint256 => Job) jobs;\r\n\r\n    mapping(address => Freelancer) public freelancers;\r\n    mapping(address => Employer) public employers;\r\n    // mapping(address => bool) completedByFreelancers;\r\n    mapping(address => mapping(uint256 => uint)) escrowFunds;\r\n\r\n\r\n    event JobCreated(uint jobId, string title);\r\n    event FreelancerRegistered(address freelancerAddress, string name);\r\n    event EmployerRegistered(address EmployerAddress, string name);\r\n    event JobCompleted(uint jobId, address freelancerAddress, uint payment);\r\n    event FundsDeposited(uint jobId, address sender, uint amount);\r\n    event FundsReleased(uint jobId, address freelancerAddress, uint amount);\r\n    event AppliedForJob(uint jobId, address employerAddress, address freelancerAddress);\r\n    event WithdrawFund(address freelancer, uint amount);\r\n\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyEmployer(address _employerAddress){\r\n        require(employers[msg.sender].employerAddress == _employerAddress, \"OEF\"); // only employer can call this function\r\n\r\n        _;\r\n    }\r\n\r\n     modifier onlyFreelancer(address _freelancerAddress){\r\n        require(freelancers[msg.sender].freelancerAddress == _freelancerAddress, \"OFF\"); // only freelancer can call this function\r\n        _;\r\n    }\r\n\r\n     /// @notice job creation and increment job count,\r\n    /// @param _title, @param _description, @param _budget\r\n    function createJob(string memory _title, string memory _description, uint256 _budget) public onlyEmployer(msg.sender){\r\n        totalJobs++;\r\n        uint8 jobId = totalJobs;\r\n        jobs[jobId] = Job(jobId,payable(msg.sender),_title,_description,_budget,false,new address[](0),address(0));    \r\n        emit JobCreated(jobId, _title);\r\n    }\r\n\r\n    /// @notice retrieves job by ID\r\n    /// @param jobId, jobId\r\n    /// @return props\r\n     function getJobByID(uint256 jobId) external view returns(Job memory props) {\r\n        require(jobId > 0 && jobId <= totalJobs, \"IJ\"); //invalid job\r\n        props = jobs[jobId];\r\n    }\r\n\r\n    /// @notice retrieves all jobs\r\n    /// @return props\r\n    \r\n    function allJobs() external view returns(Job[] memory props){\r\n        props = new Job[](totalJobs);\r\n        for (uint i = 0; i < totalJobs; i++) {\r\n            props[i] = jobs[i];\r\n        }\r\n\r\n    }\r\n\r\n\r\n      /// @notice job application\r\n    /// @param jobId, job id\r\n    function applyForJob(uint jobId) public {\r\n        require(jobId <= totalJobs && jobId > 0, \"JDE\"); // job does not exist\r\n        Job storage job = jobs[jobId];\r\n        require(job.employer != address(0), \"JNF\"); // Job not found\r\n        require(msg.sender != address(0), \"IA.\"); //invalid applicant\r\n\r\n        for (uint i = 0; i < job.applicants.length; i++) {\r\n            if (job.applicants[i] == msg.sender) {\r\n                revert(\"YHA\"); //You have already applied for this job.\r\n            }\r\n        }\r\n\r\n        job.applicants.push(msg.sender);\r\n\r\n        emit AppliedForJob(jobId,job.employer,msg.sender);\r\n    }\r\n\r\n    /// @notice process job completion\r\n    /// @param jobId, @param freelancerAddress\r\n    function completeJob(uint jobId, address freelancerAddress) public onlyEmployer(msg.sender) {\r\n        require(jobId <= totalJobs && jobId > 0, \"JDE\"); // job does not exist\r\n        Job storage job = jobs[jobId];\r\n        require(job.employer != address(0), \"JNF\"); // job not found\r\n        require(isFreelancerHired(job, freelancerAddress), \"FNH\"); //Freelancer is not hired for this job\r\n        // mark the job as completed\r\n        uint payment = job.budget;\r\n        job.completed = true;\r\n        totalCompletedJobs++;\r\n        freelancers[freelancerAddress].jobsCompleted++;\r\n        emit JobCompleted(jobId, freelancerAddress, payment);\r\n    }\r\n\r\n      /// @notice check if freelancer is hired\r\n        /// @param job , @param freelancerAddress\r\n        /// @return bool\r\n    function isFreelancerHired(Job storage job, address freelancerAddress) internal view returns (bool) {\r\n        if (job.hiredFreelancer == freelancerAddress) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}